#include <stdio.h>
#include <stdlib.h>

/*
 * unity build, include all source code once here
 * then we can build project with `cc main.c` and it should just work
 */
#include "binary_search_tree.c"
#include "single_shortest_path.c"

int main(void) {
  printf("binary search tree tests:\n");
  {
    Node example2 = {
        .key = 2,
    };
    Node example5a = {
        .key = 5,
    };
    Node example8 = {
        .key = 8,
    };
    Node example5b = {
        .key = 5,
    };
    Node example7 = {
        .key = 7,
    };
    Node example6 = {
        .key = 6,
    };

    example6.left = &example5b;
    example6.right = &example7;

    example5b.parent = &example6;
    example5b.left = &example2;
    example5b.right = &example5a;

    example7.parent = &example6;
    example7.right = &example8;

    example2.parent = &example5b;

    example5a.parent = &example5b;

    example8.parent = &example7;

    printf("print_in_order\n");
    print_in_order(&example6);

    printf("\n");
    printf("rec_search\n");
    Node *rec_search2_res = rec_search(&example6, 2);
    Node *rec_search5_res = rec_search(&example6, 5);
    Node *rec_search8_res = rec_search(&example6, 8);
    printf("rec_search2_res as expected: %d\n", rec_search2_res == &example2);
    printf("rec_search5_res as expected: %d\n", rec_search5_res == &example5b);
    printf("rec_search8_res as expected: %d\n", rec_search8_res == &example8);

    printf("\n");
    printf("itr_search\n");
    Node *itr_search2_res = itr_search(&example6, 2);
    Node *itr_search5_res = itr_search(&example6, 5);
    Node *itr_search8_res = itr_search(&example6, 8);
    printf("itr_search2_res as expected: %d\n", itr_search2_res == &example2);
    printf("itr_search5_res as expected: %d\n", itr_search5_res == &example5b);
    printf("itr_search8_res as expected: %d\n", itr_search8_res == &example8);

    printf("\n");
    printf("maximum as expected: %d\n", maximum(&example6) == &example8);
    printf("minimum as expected: %d\n", minimum(&example6) == &example2);

    printf("\n");
    printf("successor of 2 as expected: %d\n",
           successor(&example2) == &example5b);
    printf("successor of 5b as expected: %d\n",
           successor(&example5b) == &example5a);
    printf("successor of 5a as expected: %d\n",
           successor(&example5a) == &example6);
    printf("successor of 6 as expected: %d\n",
           successor(&example6) == &example7);
    printf("successor of 7 as expected: %d\n",
           successor(&example7) == &example8);
    printf("successor of 8 as expected: %d\n", successor(&example8) == NULL);

    printf("\n");
    printf("predecessor of 2 as expected: %d\n",
           predecessor(&example2) == NULL);
    printf("predecessor of 5b as expected: %d\n",
           predecessor(&example5b) == &example2);
    printf("predecessor of 5a as expected: %d\n",
           predecessor(&example5a) == &example5b);
    printf("predecessor of 6 as expected: %d\n",
           predecessor(&example6) == &example5a);
    printf("predecessor of 7 as expected: %d\n",
           predecessor(&example7) == &example6);
    printf("predecessor of 8 as expected: %d\n",
           predecessor(&example8) == &example7);

    int random_ints_count = 5;
    int64_t *random_ints = malloc(random_ints_count * sizeof(int64_t));
    for (int i = 0; i < random_ints_count; ++i) {
      random_ints[i] = rand();
    }
    Node *nodes = malloc(random_ints_count * sizeof(Node));
    BinarySearchTree tree = {0};
    for (int i = 0; i < random_ints_count; ++i) {
      nodes[i].key = random_ints[i];
      tree_insert(&tree, &nodes[i]);
    }
    printf("tree generated by repeated inserts is valid: %d\n",
           is_binary_search_tree(tree.root));
    printf("nodes in tree: %d\n", count_nodes_in_tree(tree.root));

    bool node_deletion_working_as_expected = true;
    int expected_tree_node_count = random_ints_count;
    for (int i = 0; i < random_ints_count; ++i) {
      tree_delete(&tree, &nodes[i]);
      expected_tree_node_count -= 1;
      node_deletion_working_as_expected =
          is_binary_search_tree(tree.root) &&
          count_nodes_in_tree(tree.root) == expected_tree_node_count;
    }
    printf("node deletion working as expected: %d\n",
           node_deletion_working_as_expected);
    printf("tree is empty: %d\n", tree.root == NULL);
    free(nodes);
    free(random_ints);
  }

  printf("single shortest path tests\n");
  {
    double weights[] = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8};
    Graph g = graph_create(5, 8, "0-1 1-2 2-3 3-4 4-3 3-2 2-1 1-0", weights);
    if (!graph_bellman_ford(&g, 4)) {
      fprintf(stderr, "invalid output graph\n");
      exit(1);
    }
    graph_print(g);
    graph_destroy(g);

    g = graph_create(5, 8, "1-0 2-1 3-2 4-3 3-4 2-3 1-2 0-1", weights);
    if (!graph_bellman_ford(&g, 4)) {
      fprintf(stderr, "invalid output graph 2\n");
      exit(1);
    }
    graph_print(g);
    graph_destroy(g);
  }
}
